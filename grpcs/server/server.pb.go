// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server.proto

package grpc_server

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// info
type TimesStat struct {
	Cpu       string  `protobuf:"bytes,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	User      float64 `protobuf:"fixed64,2,opt,name=user,proto3" json:"user,omitempty"`
	System    float64 `protobuf:"fixed64,3,opt,name=system,proto3" json:"system,omitempty"`
	Idle      float64 `protobuf:"fixed64,4,opt,name=idle,proto3" json:"idle,omitempty"`
	Nice      float64 `protobuf:"fixed64,5,opt,name=nice,proto3" json:"nice,omitempty"`
	Iowait    float64 `protobuf:"fixed64,6,opt,name=iowait,proto3" json:"iowait,omitempty"`
	Irq       float64 `protobuf:"fixed64,7,opt,name=irq,proto3" json:"irq,omitempty"`
	Softirq   float64 `protobuf:"fixed64,8,opt,name=softirq,proto3" json:"softirq,omitempty"`
	Steal     float64 `protobuf:"fixed64,9,opt,name=steal,proto3" json:"steal,omitempty"`
	Guest     float64 `protobuf:"fixed64,10,opt,name=guest,proto3" json:"guest,omitempty"`
	GuestNice float64 `protobuf:"fixed64,11,opt,name=guestNice,proto3" json:"guestNice,omitempty"`
}

func (m *TimesStat) Reset()         { *m = TimesStat{} }
func (m *TimesStat) String() string { return proto.CompactTextString(m) }
func (*TimesStat) ProtoMessage()    {}
func (*TimesStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{0}
}
func (m *TimesStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimesStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimesStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimesStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimesStat.Merge(m, src)
}
func (m *TimesStat) XXX_Size() int {
	return m.Size()
}
func (m *TimesStat) XXX_DiscardUnknown() {
	xxx_messageInfo_TimesStat.DiscardUnknown(m)
}

var xxx_messageInfo_TimesStat proto.InternalMessageInfo

func (m *TimesStat) GetCpu() string {
	if m != nil {
		return m.Cpu
	}
	return ""
}

func (m *TimesStat) GetUser() float64 {
	if m != nil {
		return m.User
	}
	return 0
}

func (m *TimesStat) GetSystem() float64 {
	if m != nil {
		return m.System
	}
	return 0
}

func (m *TimesStat) GetIdle() float64 {
	if m != nil {
		return m.Idle
	}
	return 0
}

func (m *TimesStat) GetNice() float64 {
	if m != nil {
		return m.Nice
	}
	return 0
}

func (m *TimesStat) GetIowait() float64 {
	if m != nil {
		return m.Iowait
	}
	return 0
}

func (m *TimesStat) GetIrq() float64 {
	if m != nil {
		return m.Irq
	}
	return 0
}

func (m *TimesStat) GetSoftirq() float64 {
	if m != nil {
		return m.Softirq
	}
	return 0
}

func (m *TimesStat) GetSteal() float64 {
	if m != nil {
		return m.Steal
	}
	return 0
}

func (m *TimesStat) GetGuest() float64 {
	if m != nil {
		return m.Guest
	}
	return 0
}

func (m *TimesStat) GetGuestNice() float64 {
	if m != nil {
		return m.GuestNice
	}
	return 0
}

type InfoStat struct {
	Cpu        int32    `protobuf:"varint,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	VendorId   string   `protobuf:"bytes,2,opt,name=vendorId,proto3" json:"vendorId,omitempty"`
	Family     string   `protobuf:"bytes,3,opt,name=family,proto3" json:"family,omitempty"`
	Model      string   `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	Stepping   int32    `protobuf:"varint,5,opt,name=stepping,proto3" json:"stepping,omitempty"`
	PhysicalId string   `protobuf:"bytes,6,opt,name=physicalId,proto3" json:"physicalId,omitempty"`
	CoreId     string   `protobuf:"bytes,7,opt,name=coreId,proto3" json:"coreId,omitempty"`
	Cores      int32    `protobuf:"varint,8,opt,name=cores,proto3" json:"cores,omitempty"`
	ModelName  string   `protobuf:"bytes,9,opt,name=modelName,proto3" json:"modelName,omitempty"`
	Mhz        float64  `protobuf:"fixed64,10,opt,name=mhz,proto3" json:"mhz,omitempty"`
	CacheSize  int32    `protobuf:"varint,11,opt,name=cacheSize,proto3" json:"cacheSize,omitempty"`
	Flags      []string `protobuf:"bytes,12,rep,name=flags,proto3" json:"flags,omitempty"`
	Microcode  string   `protobuf:"bytes,13,opt,name=microcode,proto3" json:"microcode,omitempty"`
}

func (m *InfoStat) Reset()         { *m = InfoStat{} }
func (m *InfoStat) String() string { return proto.CompactTextString(m) }
func (*InfoStat) ProtoMessage()    {}
func (*InfoStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{1}
}
func (m *InfoStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfoStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfoStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfoStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoStat.Merge(m, src)
}
func (m *InfoStat) XXX_Size() int {
	return m.Size()
}
func (m *InfoStat) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoStat.DiscardUnknown(m)
}

var xxx_messageInfo_InfoStat proto.InternalMessageInfo

func (m *InfoStat) GetCpu() int32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *InfoStat) GetVendorId() string {
	if m != nil {
		return m.VendorId
	}
	return ""
}

func (m *InfoStat) GetFamily() string {
	if m != nil {
		return m.Family
	}
	return ""
}

func (m *InfoStat) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *InfoStat) GetStepping() int32 {
	if m != nil {
		return m.Stepping
	}
	return 0
}

func (m *InfoStat) GetPhysicalId() string {
	if m != nil {
		return m.PhysicalId
	}
	return ""
}

func (m *InfoStat) GetCoreId() string {
	if m != nil {
		return m.CoreId
	}
	return ""
}

func (m *InfoStat) GetCores() int32 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *InfoStat) GetModelName() string {
	if m != nil {
		return m.ModelName
	}
	return ""
}

func (m *InfoStat) GetMhz() float64 {
	if m != nil {
		return m.Mhz
	}
	return 0
}

func (m *InfoStat) GetCacheSize() int32 {
	if m != nil {
		return m.CacheSize
	}
	return 0
}

func (m *InfoStat) GetFlags() []string {
	if m != nil {
		return m.Flags
	}
	return nil
}

func (m *InfoStat) GetMicrocode() string {
	if m != nil {
		return m.Microcode
	}
	return ""
}

type Cpus struct {
	CpuInfo  []*InfoStat  `protobuf:"bytes,1,rep,name=cpu_info,json=cpuInfo,proto3" json:"cpu_info,omitempty"`
	CpuTimes []*TimesStat `protobuf:"bytes,2,rep,name=cpu_times,json=cpuTimes,proto3" json:"cpu_times,omitempty"`
}

func (m *Cpus) Reset()         { *m = Cpus{} }
func (m *Cpus) String() string { return proto.CompactTextString(m) }
func (*Cpus) ProtoMessage()    {}
func (*Cpus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{2}
}
func (m *Cpus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cpus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cpus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cpus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cpus.Merge(m, src)
}
func (m *Cpus) XXX_Size() int {
	return m.Size()
}
func (m *Cpus) XXX_DiscardUnknown() {
	xxx_messageInfo_Cpus.DiscardUnknown(m)
}

var xxx_messageInfo_Cpus proto.InternalMessageInfo

func (m *Cpus) GetCpuInfo() []*InfoStat {
	if m != nil {
		return m.CpuInfo
	}
	return nil
}

func (m *Cpus) GetCpuTimes() []*TimesStat {
	if m != nil {
		return m.CpuTimes
	}
	return nil
}

type Info struct {
	Uuid     string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Ipv4     string `protobuf:"bytes,3,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	Time     uint64 `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *Info) Reset()         { *m = Info{} }
func (m *Info) String() string { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()    {}
func (*Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{3}
}
func (m *Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Info.Merge(m, src)
}
func (m *Info) XXX_Size() int {
	return m.Size()
}
func (m *Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Info proto.InternalMessageInfo

func (m *Info) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Info) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Info) GetIpv4() string {
	if m != nil {
		return m.Ipv4
	}
	return ""
}

func (m *Info) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

// 磁盘
type UsageStat struct {
	Path              string  `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Fstype            string  `protobuf:"bytes,2,opt,name=fstype,proto3" json:"fstype,omitempty"`
	Total             uint64  `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
	Free              uint64  `protobuf:"varint,4,opt,name=free,proto3" json:"free,omitempty"`
	Used              uint64  `protobuf:"varint,5,opt,name=used,proto3" json:"used,omitempty"`
	UsedPercent       float64 `protobuf:"fixed64,6,opt,name=usedPercent,proto3" json:"usedPercent,omitempty"`
	InodesTotal       uint64  `protobuf:"varint,7,opt,name=inodesTotal,proto3" json:"inodesTotal,omitempty"`
	InodesUsed        uint64  `protobuf:"varint,8,opt,name=inodesUsed,proto3" json:"inodesUsed,omitempty"`
	InodesFree        uint64  `protobuf:"varint,9,opt,name=inodesFree,proto3" json:"inodesFree,omitempty"`
	InodesUsedPercent float64 `protobuf:"fixed64,10,opt,name=inodesUsedPercent,proto3" json:"inodesUsedPercent,omitempty"`
}

func (m *UsageStat) Reset()         { *m = UsageStat{} }
func (m *UsageStat) String() string { return proto.CompactTextString(m) }
func (*UsageStat) ProtoMessage()    {}
func (*UsageStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{4}
}
func (m *UsageStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageStat.Merge(m, src)
}
func (m *UsageStat) XXX_Size() int {
	return m.Size()
}
func (m *UsageStat) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageStat.DiscardUnknown(m)
}

var xxx_messageInfo_UsageStat proto.InternalMessageInfo

func (m *UsageStat) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *UsageStat) GetFstype() string {
	if m != nil {
		return m.Fstype
	}
	return ""
}

func (m *UsageStat) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *UsageStat) GetFree() uint64 {
	if m != nil {
		return m.Free
	}
	return 0
}

func (m *UsageStat) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *UsageStat) GetUsedPercent() float64 {
	if m != nil {
		return m.UsedPercent
	}
	return 0
}

func (m *UsageStat) GetInodesTotal() uint64 {
	if m != nil {
		return m.InodesTotal
	}
	return 0
}

func (m *UsageStat) GetInodesUsed() uint64 {
	if m != nil {
		return m.InodesUsed
	}
	return 0
}

func (m *UsageStat) GetInodesFree() uint64 {
	if m != nil {
		return m.InodesFree
	}
	return 0
}

func (m *UsageStat) GetInodesUsedPercent() float64 {
	if m != nil {
		return m.InodesUsedPercent
	}
	return 0
}

type PartitionStat struct {
	Device     string   `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	Mountpoint string   `protobuf:"bytes,2,opt,name=mountpoint,proto3" json:"mountpoint,omitempty"`
	Fstype     string   `protobuf:"bytes,3,opt,name=fstype,proto3" json:"fstype,omitempty"`
	Opts       []string `protobuf:"bytes,4,rep,name=opts,proto3" json:"opts,omitempty"`
}

func (m *PartitionStat) Reset()         { *m = PartitionStat{} }
func (m *PartitionStat) String() string { return proto.CompactTextString(m) }
func (*PartitionStat) ProtoMessage()    {}
func (*PartitionStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{5}
}
func (m *PartitionStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionStat.Merge(m, src)
}
func (m *PartitionStat) XXX_Size() int {
	return m.Size()
}
func (m *PartitionStat) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionStat.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionStat proto.InternalMessageInfo

func (m *PartitionStat) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *PartitionStat) GetMountpoint() string {
	if m != nil {
		return m.Mountpoint
	}
	return ""
}

func (m *PartitionStat) GetFstype() string {
	if m != nil {
		return m.Fstype
	}
	return ""
}

func (m *PartitionStat) GetOpts() []string {
	if m != nil {
		return m.Opts
	}
	return nil
}

type IOCountersStat struct {
	ReadCount        uint64 `protobuf:"varint,1,opt,name=readCount,proto3" json:"readCount,omitempty"`
	MergedReadCount  uint64 `protobuf:"varint,2,opt,name=mergedReadCount,proto3" json:"mergedReadCount,omitempty"`
	WriteCount       uint64 `protobuf:"varint,3,opt,name=writeCount,proto3" json:"writeCount,omitempty"`
	MergedWriteCount uint64 `protobuf:"varint,4,opt,name=mergedWriteCount,proto3" json:"mergedWriteCount,omitempty"`
	ReadBytes        uint64 `protobuf:"varint,5,opt,name=readBytes,proto3" json:"readBytes,omitempty"`
	WriteBytes       uint64 `protobuf:"varint,6,opt,name=writeBytes,proto3" json:"writeBytes,omitempty"`
	ReadTime         uint64 `protobuf:"varint,7,opt,name=readTime,proto3" json:"readTime,omitempty"`
	WriteTime        uint64 `protobuf:"varint,8,opt,name=writeTime,proto3" json:"writeTime,omitempty"`
	IopsInProgress   uint64 `protobuf:"varint,9,opt,name=iopsInProgress,proto3" json:"iopsInProgress,omitempty"`
	IoTime           uint64 `protobuf:"varint,10,opt,name=ioTime,proto3" json:"ioTime,omitempty"`
	WeightedIO       uint64 `protobuf:"varint,11,opt,name=weightedIO,proto3" json:"weightedIO,omitempty"`
	Name             string `protobuf:"bytes,12,opt,name=name,proto3" json:"name,omitempty"`
	SerialNumber     string `protobuf:"bytes,13,opt,name=serialNumber,proto3" json:"serialNumber,omitempty"`
	Label            string `protobuf:"bytes,14,opt,name=label,proto3" json:"label,omitempty"`
}

func (m *IOCountersStat) Reset()         { *m = IOCountersStat{} }
func (m *IOCountersStat) String() string { return proto.CompactTextString(m) }
func (*IOCountersStat) ProtoMessage()    {}
func (*IOCountersStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{6}
}
func (m *IOCountersStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IOCountersStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IOCountersStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IOCountersStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IOCountersStat.Merge(m, src)
}
func (m *IOCountersStat) XXX_Size() int {
	return m.Size()
}
func (m *IOCountersStat) XXX_DiscardUnknown() {
	xxx_messageInfo_IOCountersStat.DiscardUnknown(m)
}

var xxx_messageInfo_IOCountersStat proto.InternalMessageInfo

func (m *IOCountersStat) GetReadCount() uint64 {
	if m != nil {
		return m.ReadCount
	}
	return 0
}

func (m *IOCountersStat) GetMergedReadCount() uint64 {
	if m != nil {
		return m.MergedReadCount
	}
	return 0
}

func (m *IOCountersStat) GetWriteCount() uint64 {
	if m != nil {
		return m.WriteCount
	}
	return 0
}

func (m *IOCountersStat) GetMergedWriteCount() uint64 {
	if m != nil {
		return m.MergedWriteCount
	}
	return 0
}

func (m *IOCountersStat) GetReadBytes() uint64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

func (m *IOCountersStat) GetWriteBytes() uint64 {
	if m != nil {
		return m.WriteBytes
	}
	return 0
}

func (m *IOCountersStat) GetReadTime() uint64 {
	if m != nil {
		return m.ReadTime
	}
	return 0
}

func (m *IOCountersStat) GetWriteTime() uint64 {
	if m != nil {
		return m.WriteTime
	}
	return 0
}

func (m *IOCountersStat) GetIopsInProgress() uint64 {
	if m != nil {
		return m.IopsInProgress
	}
	return 0
}

func (m *IOCountersStat) GetIoTime() uint64 {
	if m != nil {
		return m.IoTime
	}
	return 0
}

func (m *IOCountersStat) GetWeightedIO() uint64 {
	if m != nil {
		return m.WeightedIO
	}
	return 0
}

func (m *IOCountersStat) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IOCountersStat) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *IOCountersStat) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

type Disk struct {
	U *UsageStat       `protobuf:"bytes,1,opt,name=U,proto3" json:"U,omitempty"`
	P []*PartitionStat `protobuf:"bytes,2,rep,name=p,proto3" json:"p,omitempty"`
	// 使用 repeated 表示键值对的映射，通过传递键值对列表模拟 map
	IO map[string]*IOCountersStat `protobuf:"bytes,3,rep,name=IO,proto3" json:"IO,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Disk) Reset()         { *m = Disk{} }
func (m *Disk) String() string { return proto.CompactTextString(m) }
func (*Disk) ProtoMessage()    {}
func (*Disk) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{7}
}
func (m *Disk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Disk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Disk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Disk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Disk.Merge(m, src)
}
func (m *Disk) XXX_Size() int {
	return m.Size()
}
func (m *Disk) XXX_DiscardUnknown() {
	xxx_messageInfo_Disk.DiscardUnknown(m)
}

var xxx_messageInfo_Disk proto.InternalMessageInfo

func (m *Disk) GetU() *UsageStat {
	if m != nil {
		return m.U
	}
	return nil
}

func (m *Disk) GetP() []*PartitionStat {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *Disk) GetIO() map[string]*IOCountersStat {
	if m != nil {
		return m.IO
	}
	return nil
}

type VirtualMemoryStat struct {
	// Total amount of RAM on this system
	Total uint64 `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	// RAM available for programs to allocate
	Available uint64 `protobuf:"varint,2,opt,name=available,proto3" json:"available,omitempty"`
	// RAM used by programs
	Used uint64 `protobuf:"varint,3,opt,name=used,proto3" json:"used,omitempty"`
	// Percentage of RAM used by programs
	UsedPercent float64 `protobuf:"fixed64,4,opt,name=used_percent,json=usedPercent,proto3" json:"used_percent,omitempty"`
	// Kernel's notion of free memory
	Free uint64 `protobuf:"varint,5,opt,name=free,proto3" json:"free,omitempty"`
	// OS X / BSD specific numbers
	Active   uint64 `protobuf:"varint,6,opt,name=active,proto3" json:"active,omitempty"`
	Inactive uint64 `protobuf:"varint,7,opt,name=inactive,proto3" json:"inactive,omitempty"`
	Wired    uint64 `protobuf:"varint,8,opt,name=wired,proto3" json:"wired,omitempty"`
	// FreeBSD specific numbers
	Laundry uint64 `protobuf:"varint,9,opt,name=laundry,proto3" json:"laundry,omitempty"`
	// Linux specific numbers
	Buffers        uint64 `protobuf:"varint,10,opt,name=buffers,proto3" json:"buffers,omitempty"`
	Cached         uint64 `protobuf:"varint,11,opt,name=cached,proto3" json:"cached,omitempty"`
	WriteBack      uint64 `protobuf:"varint,12,opt,name=write_back,json=writeBack,proto3" json:"write_back,omitempty"`
	Dirty          uint64 `protobuf:"varint,13,opt,name=dirty,proto3" json:"dirty,omitempty"`
	WriteBackTmp   uint64 `protobuf:"varint,14,opt,name=write_back_tmp,json=writeBackTmp,proto3" json:"write_back_tmp,omitempty"`
	Shared         uint64 `protobuf:"varint,15,opt,name=shared,proto3" json:"shared,omitempty"`
	Slab           uint64 `protobuf:"varint,16,opt,name=slab,proto3" json:"slab,omitempty"`
	Sreclaimable   uint64 `protobuf:"varint,17,opt,name=sreclaimable,proto3" json:"sreclaimable,omitempty"`
	Sunreclaim     uint64 `protobuf:"varint,18,opt,name=sunreclaim,proto3" json:"sunreclaim,omitempty"`
	PageTables     uint64 `protobuf:"varint,19,opt,name=page_tables,json=pageTables,proto3" json:"page_tables,omitempty"`
	SwapCached     uint64 `protobuf:"varint,20,opt,name=swap_cached,json=swapCached,proto3" json:"swap_cached,omitempty"`
	CommitLimit    uint64 `protobuf:"varint,21,opt,name=commit_limit,json=commitLimit,proto3" json:"commit_limit,omitempty"`
	CommittedAs    uint64 `protobuf:"varint,22,opt,name=committed_as,json=committedAs,proto3" json:"committed_as,omitempty"`
	HighTotal      uint64 `protobuf:"varint,23,opt,name=high_total,json=highTotal,proto3" json:"high_total,omitempty"`
	HighFree       uint64 `protobuf:"varint,24,opt,name=high_free,json=highFree,proto3" json:"high_free,omitempty"`
	LowTotal       uint64 `protobuf:"varint,25,opt,name=low_total,json=lowTotal,proto3" json:"low_total,omitempty"`
	LowFree        uint64 `protobuf:"varint,26,opt,name=low_free,json=lowFree,proto3" json:"low_free,omitempty"`
	SwapTotal      uint64 `protobuf:"varint,27,opt,name=swap_total,json=swapTotal,proto3" json:"swap_total,omitempty"`
	SwapFree       uint64 `protobuf:"varint,28,opt,name=swap_free,json=swapFree,proto3" json:"swap_free,omitempty"`
	Mapped         uint64 `protobuf:"varint,29,opt,name=mapped,proto3" json:"mapped,omitempty"`
	VmallocTotal   uint64 `protobuf:"varint,30,opt,name=vmalloc_total,json=vmallocTotal,proto3" json:"vmalloc_total,omitempty"`
	VmallocUsed    uint64 `protobuf:"varint,31,opt,name=vmalloc_used,json=vmallocUsed,proto3" json:"vmalloc_used,omitempty"`
	VmallocChunk   uint64 `protobuf:"varint,32,opt,name=vmalloc_chunk,json=vmallocChunk,proto3" json:"vmalloc_chunk,omitempty"`
	HugePagesTotal uint64 `protobuf:"varint,33,opt,name=huge_pages_total,json=hugePagesTotal,proto3" json:"huge_pages_total,omitempty"`
	HugePagesFree  uint64 `protobuf:"varint,34,opt,name=huge_pages_free,json=hugePagesFree,proto3" json:"huge_pages_free,omitempty"`
	HugePagesRsvd  uint64 `protobuf:"varint,35,opt,name=huge_pages_rsvd,json=hugePagesRsvd,proto3" json:"huge_pages_rsvd,omitempty"`
	HugePagesSurp  uint64 `protobuf:"varint,36,opt,name=huge_pages_surp,json=hugePagesSurp,proto3" json:"huge_pages_surp,omitempty"`
	HugePageSize   uint64 `protobuf:"varint,37,opt,name=huge_page_size,json=hugePageSize,proto3" json:"huge_page_size,omitempty"`
	AnonHugePages  uint64 `protobuf:"varint,38,opt,name=anon_huge_pages,json=anonHugePages,proto3" json:"anon_huge_pages,omitempty"`
}

func (m *VirtualMemoryStat) Reset()         { *m = VirtualMemoryStat{} }
func (m *VirtualMemoryStat) String() string { return proto.CompactTextString(m) }
func (*VirtualMemoryStat) ProtoMessage()    {}
func (*VirtualMemoryStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{8}
}
func (m *VirtualMemoryStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualMemoryStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VirtualMemoryStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VirtualMemoryStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualMemoryStat.Merge(m, src)
}
func (m *VirtualMemoryStat) XXX_Size() int {
	return m.Size()
}
func (m *VirtualMemoryStat) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualMemoryStat.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualMemoryStat proto.InternalMessageInfo

func (m *VirtualMemoryStat) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *VirtualMemoryStat) GetAvailable() uint64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *VirtualMemoryStat) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *VirtualMemoryStat) GetUsedPercent() float64 {
	if m != nil {
		return m.UsedPercent
	}
	return 0
}

func (m *VirtualMemoryStat) GetFree() uint64 {
	if m != nil {
		return m.Free
	}
	return 0
}

func (m *VirtualMemoryStat) GetActive() uint64 {
	if m != nil {
		return m.Active
	}
	return 0
}

func (m *VirtualMemoryStat) GetInactive() uint64 {
	if m != nil {
		return m.Inactive
	}
	return 0
}

func (m *VirtualMemoryStat) GetWired() uint64 {
	if m != nil {
		return m.Wired
	}
	return 0
}

func (m *VirtualMemoryStat) GetLaundry() uint64 {
	if m != nil {
		return m.Laundry
	}
	return 0
}

func (m *VirtualMemoryStat) GetBuffers() uint64 {
	if m != nil {
		return m.Buffers
	}
	return 0
}

func (m *VirtualMemoryStat) GetCached() uint64 {
	if m != nil {
		return m.Cached
	}
	return 0
}

func (m *VirtualMemoryStat) GetWriteBack() uint64 {
	if m != nil {
		return m.WriteBack
	}
	return 0
}

func (m *VirtualMemoryStat) GetDirty() uint64 {
	if m != nil {
		return m.Dirty
	}
	return 0
}

func (m *VirtualMemoryStat) GetWriteBackTmp() uint64 {
	if m != nil {
		return m.WriteBackTmp
	}
	return 0
}

func (m *VirtualMemoryStat) GetShared() uint64 {
	if m != nil {
		return m.Shared
	}
	return 0
}

func (m *VirtualMemoryStat) GetSlab() uint64 {
	if m != nil {
		return m.Slab
	}
	return 0
}

func (m *VirtualMemoryStat) GetSreclaimable() uint64 {
	if m != nil {
		return m.Sreclaimable
	}
	return 0
}

func (m *VirtualMemoryStat) GetSunreclaim() uint64 {
	if m != nil {
		return m.Sunreclaim
	}
	return 0
}

func (m *VirtualMemoryStat) GetPageTables() uint64 {
	if m != nil {
		return m.PageTables
	}
	return 0
}

func (m *VirtualMemoryStat) GetSwapCached() uint64 {
	if m != nil {
		return m.SwapCached
	}
	return 0
}

func (m *VirtualMemoryStat) GetCommitLimit() uint64 {
	if m != nil {
		return m.CommitLimit
	}
	return 0
}

func (m *VirtualMemoryStat) GetCommittedAs() uint64 {
	if m != nil {
		return m.CommittedAs
	}
	return 0
}

func (m *VirtualMemoryStat) GetHighTotal() uint64 {
	if m != nil {
		return m.HighTotal
	}
	return 0
}

func (m *VirtualMemoryStat) GetHighFree() uint64 {
	if m != nil {
		return m.HighFree
	}
	return 0
}

func (m *VirtualMemoryStat) GetLowTotal() uint64 {
	if m != nil {
		return m.LowTotal
	}
	return 0
}

func (m *VirtualMemoryStat) GetLowFree() uint64 {
	if m != nil {
		return m.LowFree
	}
	return 0
}

func (m *VirtualMemoryStat) GetSwapTotal() uint64 {
	if m != nil {
		return m.SwapTotal
	}
	return 0
}

func (m *VirtualMemoryStat) GetSwapFree() uint64 {
	if m != nil {
		return m.SwapFree
	}
	return 0
}

func (m *VirtualMemoryStat) GetMapped() uint64 {
	if m != nil {
		return m.Mapped
	}
	return 0
}

func (m *VirtualMemoryStat) GetVmallocTotal() uint64 {
	if m != nil {
		return m.VmallocTotal
	}
	return 0
}

func (m *VirtualMemoryStat) GetVmallocUsed() uint64 {
	if m != nil {
		return m.VmallocUsed
	}
	return 0
}

func (m *VirtualMemoryStat) GetVmallocChunk() uint64 {
	if m != nil {
		return m.VmallocChunk
	}
	return 0
}

func (m *VirtualMemoryStat) GetHugePagesTotal() uint64 {
	if m != nil {
		return m.HugePagesTotal
	}
	return 0
}

func (m *VirtualMemoryStat) GetHugePagesFree() uint64 {
	if m != nil {
		return m.HugePagesFree
	}
	return 0
}

func (m *VirtualMemoryStat) GetHugePagesRsvd() uint64 {
	if m != nil {
		return m.HugePagesRsvd
	}
	return 0
}

func (m *VirtualMemoryStat) GetHugePagesSurp() uint64 {
	if m != nil {
		return m.HugePagesSurp
	}
	return 0
}

func (m *VirtualMemoryStat) GetHugePageSize() uint64 {
	if m != nil {
		return m.HugePageSize
	}
	return 0
}

func (m *VirtualMemoryStat) GetAnonHugePages() uint64 {
	if m != nil {
		return m.AnonHugePages
	}
	return 0
}

type SwapMemoryStat struct {
	Total       uint64  `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Used        uint64  `protobuf:"varint,2,opt,name=used,proto3" json:"used,omitempty"`
	Free        uint64  `protobuf:"varint,3,opt,name=free,proto3" json:"free,omitempty"`
	UsedPercent float64 `protobuf:"fixed64,4,opt,name=used_percent,json=usedPercent,proto3" json:"used_percent,omitempty"`
	Sin         uint64  `protobuf:"varint,5,opt,name=sin,proto3" json:"sin,omitempty"`
	Sout        uint64  `protobuf:"varint,6,opt,name=sout,proto3" json:"sout,omitempty"`
	PgIn        uint64  `protobuf:"varint,7,opt,name=pg_in,json=pgIn,proto3" json:"pg_in,omitempty"`
	PgOut       uint64  `protobuf:"varint,8,opt,name=pg_out,json=pgOut,proto3" json:"pg_out,omitempty"`
	PgFault     uint64  `protobuf:"varint,9,opt,name=pg_fault,json=pgFault,proto3" json:"pg_fault,omitempty"`
	// Linux specific numbers
	PgMajFault uint64 `protobuf:"varint,10,opt,name=pg_maj_fault,json=pgMajFault,proto3" json:"pg_maj_fault,omitempty"`
}

func (m *SwapMemoryStat) Reset()         { *m = SwapMemoryStat{} }
func (m *SwapMemoryStat) String() string { return proto.CompactTextString(m) }
func (*SwapMemoryStat) ProtoMessage()    {}
func (*SwapMemoryStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{9}
}
func (m *SwapMemoryStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapMemoryStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapMemoryStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapMemoryStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapMemoryStat.Merge(m, src)
}
func (m *SwapMemoryStat) XXX_Size() int {
	return m.Size()
}
func (m *SwapMemoryStat) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapMemoryStat.DiscardUnknown(m)
}

var xxx_messageInfo_SwapMemoryStat proto.InternalMessageInfo

func (m *SwapMemoryStat) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *SwapMemoryStat) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *SwapMemoryStat) GetFree() uint64 {
	if m != nil {
		return m.Free
	}
	return 0
}

func (m *SwapMemoryStat) GetUsedPercent() float64 {
	if m != nil {
		return m.UsedPercent
	}
	return 0
}

func (m *SwapMemoryStat) GetSin() uint64 {
	if m != nil {
		return m.Sin
	}
	return 0
}

func (m *SwapMemoryStat) GetSout() uint64 {
	if m != nil {
		return m.Sout
	}
	return 0
}

func (m *SwapMemoryStat) GetPgIn() uint64 {
	if m != nil {
		return m.PgIn
	}
	return 0
}

func (m *SwapMemoryStat) GetPgOut() uint64 {
	if m != nil {
		return m.PgOut
	}
	return 0
}

func (m *SwapMemoryStat) GetPgFault() uint64 {
	if m != nil {
		return m.PgFault
	}
	return 0
}

func (m *SwapMemoryStat) GetPgMajFault() uint64 {
	if m != nil {
		return m.PgMajFault
	}
	return 0
}

type SwapDevice struct {
	Name      string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	UsedBytes uint64 `protobuf:"varint,2,opt,name=used_bytes,json=usedBytes,proto3" json:"used_bytes,omitempty"`
	FreeBytes uint64 `protobuf:"varint,3,opt,name=free_bytes,json=freeBytes,proto3" json:"free_bytes,omitempty"`
}

func (m *SwapDevice) Reset()         { *m = SwapDevice{} }
func (m *SwapDevice) String() string { return proto.CompactTextString(m) }
func (*SwapDevice) ProtoMessage()    {}
func (*SwapDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{10}
}
func (m *SwapDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapDevice.Merge(m, src)
}
func (m *SwapDevice) XXX_Size() int {
	return m.Size()
}
func (m *SwapDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapDevice.DiscardUnknown(m)
}

var xxx_messageInfo_SwapDevice proto.InternalMessageInfo

func (m *SwapDevice) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SwapDevice) GetUsedBytes() uint64 {
	if m != nil {
		return m.UsedBytes
	}
	return 0
}

func (m *SwapDevice) GetFreeBytes() uint64 {
	if m != nil {
		return m.FreeBytes
	}
	return 0
}

type Memory struct {
	VirtualMemory *VirtualMemoryStat `protobuf:"bytes,1,opt,name=virtual_memory,json=virtualMemory,proto3" json:"virtual_memory,omitempty"`
	SwapMemory    *SwapMemoryStat    `protobuf:"bytes,2,opt,name=swap_memory,json=swapMemory,proto3" json:"swap_memory,omitempty"`
	SwapDevices   []*SwapDevice      `protobuf:"bytes,3,rep,name=swap_devices,json=swapDevices,proto3" json:"swap_devices,omitempty"`
}

func (m *Memory) Reset()         { *m = Memory{} }
func (m *Memory) String() string { return proto.CompactTextString(m) }
func (*Memory) ProtoMessage()    {}
func (*Memory) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{11}
}
func (m *Memory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Memory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Memory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Memory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Memory.Merge(m, src)
}
func (m *Memory) XXX_Size() int {
	return m.Size()
}
func (m *Memory) XXX_DiscardUnknown() {
	xxx_messageInfo_Memory.DiscardUnknown(m)
}

var xxx_messageInfo_Memory proto.InternalMessageInfo

func (m *Memory) GetVirtualMemory() *VirtualMemoryStat {
	if m != nil {
		return m.VirtualMemory
	}
	return nil
}

func (m *Memory) GetSwapMemory() *SwapMemoryStat {
	if m != nil {
		return m.SwapMemory
	}
	return nil
}

func (m *Memory) GetSwapDevices() []*SwapDevice {
	if m != nil {
		return m.SwapDevices
	}
	return nil
}

// 定义 StandData 数据结构
type StandData struct {
	Serct    string   `protobuf:"bytes,1,opt,name=serct,proto3" json:"serct,omitempty"`
	Uuid     string   `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Hostname string   `protobuf:"bytes,3,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Ipv4     string   `protobuf:"bytes,4,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	Time     uint64   `protobuf:"varint,5,opt,name=time,proto3" json:"time,omitempty"`
	Info     *Info    `protobuf:"bytes,6,opt,name=info,proto3" json:"info,omitempty"`
	Cpu      *Cpus    `protobuf:"bytes,7,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Disk     *Disk    `protobuf:"bytes,8,opt,name=disk,proto3" json:"disk,omitempty"`
	Memory   *Memory  `protobuf:"bytes,9,opt,name=memory,proto3" json:"memory,omitempty"`
	Net      []string `protobuf:"bytes,10,rep,name=net,proto3" json:"net,omitempty"`
}

func (m *StandData) Reset()         { *m = StandData{} }
func (m *StandData) String() string { return proto.CompactTextString(m) }
func (*StandData) ProtoMessage()    {}
func (*StandData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{12}
}
func (m *StandData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StandData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StandData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StandData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StandData.Merge(m, src)
}
func (m *StandData) XXX_Size() int {
	return m.Size()
}
func (m *StandData) XXX_DiscardUnknown() {
	xxx_messageInfo_StandData.DiscardUnknown(m)
}

var xxx_messageInfo_StandData proto.InternalMessageInfo

func (m *StandData) GetSerct() string {
	if m != nil {
		return m.Serct
	}
	return ""
}

func (m *StandData) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *StandData) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *StandData) GetIpv4() string {
	if m != nil {
		return m.Ipv4
	}
	return ""
}

func (m *StandData) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *StandData) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *StandData) GetCpu() *Cpus {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *StandData) GetDisk() *Disk {
	if m != nil {
		return m.Disk
	}
	return nil
}

func (m *StandData) GetMemory() *Memory {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *StandData) GetNet() []string {
	if m != nil {
		return m.Net
	}
	return nil
}

type ResponseMessage struct {
	Code    string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ResponseMessage) Reset()         { *m = ResponseMessage{} }
func (m *ResponseMessage) String() string { return proto.CompactTextString(m) }
func (*ResponseMessage) ProtoMessage()    {}
func (*ResponseMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{13}
}
func (m *ResponseMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseMessage.Merge(m, src)
}
func (m *ResponseMessage) XXX_Size() int {
	return m.Size()
}
func (m *ResponseMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseMessage proto.InternalMessageInfo

func (m *ResponseMessage) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *ResponseMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*TimesStat)(nil), "grpc_server.TimesStat")
	proto.RegisterType((*InfoStat)(nil), "grpc_server.InfoStat")
	proto.RegisterType((*Cpus)(nil), "grpc_server.Cpus")
	proto.RegisterType((*Info)(nil), "grpc_server.Info")
	proto.RegisterType((*UsageStat)(nil), "grpc_server.UsageStat")
	proto.RegisterType((*PartitionStat)(nil), "grpc_server.PartitionStat")
	proto.RegisterType((*IOCountersStat)(nil), "grpc_server.IOCountersStat")
	proto.RegisterType((*Disk)(nil), "grpc_server.Disk")
	proto.RegisterMapType((map[string]*IOCountersStat)(nil), "grpc_server.Disk.IOEntry")
	proto.RegisterType((*VirtualMemoryStat)(nil), "grpc_server.VirtualMemoryStat")
	proto.RegisterType((*SwapMemoryStat)(nil), "grpc_server.SwapMemoryStat")
	proto.RegisterType((*SwapDevice)(nil), "grpc_server.SwapDevice")
	proto.RegisterType((*Memory)(nil), "grpc_server.Memory")
	proto.RegisterType((*StandData)(nil), "grpc_server.StandData")
	proto.RegisterType((*ResponseMessage)(nil), "grpc_server.ResponseMessage")
}

func init() { proto.RegisterFile("server.proto", fileDescriptor_ad098daeda4239f7) }

var fileDescriptor_ad098daeda4239f7 = []byte{
	// 1819 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x58, 0xcd, 0x6e, 0x1b, 0xc9,
	0x11, 0x36, 0xc9, 0x21, 0xa5, 0x29, 0xfd, 0x7a, 0xbc, 0xd6, 0x8e, 0x65, 0x49, 0x96, 0xe9, 0x1f,
	0x28, 0x3f, 0xf0, 0x26, 0xde, 0x1c, 0x82, 0x45, 0x80, 0x64, 0x6d, 0xaf, 0x11, 0x02, 0xb1, 0xa5,
	0x8c, 0xec, 0xe4, 0xb6, 0x83, 0xd6, 0x4c, 0x73, 0x38, 0xab, 0xf9, 0xe9, 0x4c, 0xf7, 0x50, 0xe0,
	0x9e, 0xf2, 0x08, 0x79, 0x84, 0xdc, 0x72, 0xc8, 0x8b, 0x24, 0x39, 0x2d, 0x02, 0x04, 0xc8, 0x31,
	0xb0, 0x1f, 0x24, 0x41, 0x55, 0xf5, 0x90, 0x43, 0xca, 0x46, 0xf6, 0xc4, 0xaa, 0xaf, 0xab, 0xba,
	0xba, 0xbf, 0xae, 0xae, 0xea, 0x21, 0x6c, 0x6a, 0x59, 0x4d, 0x65, 0xf5, 0x44, 0x55, 0xa5, 0x29,
	0xbd, 0x8d, 0xa4, 0x52, 0x51, 0xc8, 0xd0, 0xfe, 0xbd, 0xa4, 0x2c, 0x93, 0x4c, 0x7e, 0x46, 0x43,
	0x17, 0xf5, 0xf8, 0x33, 0x93, 0xe6, 0x52, 0x1b, 0x91, 0x2b, 0xb6, 0x1e, 0xfe, 0xb7, 0x03, 0xee,
	0x1b, 0xc4, 0xce, 0x8d, 0x30, 0xde, 0x2e, 0xf4, 0x22, 0x55, 0xfb, 0x9d, 0xe3, 0xce, 0x89, 0x1b,
	0xa0, 0xe8, 0x79, 0xe0, 0xd4, 0x5a, 0x56, 0x7e, 0xf7, 0xb8, 0x73, 0xd2, 0x09, 0x48, 0xf6, 0xf6,
	0x60, 0xa0, 0x67, 0xda, 0xc8, 0xdc, 0xef, 0x11, 0x6a, 0x35, 0xb4, 0x4d, 0xe3, 0x4c, 0xfa, 0x0e,
	0xdb, 0xa2, 0x8c, 0x58, 0x91, 0x46, 0xd2, 0xef, 0x33, 0x86, 0x32, 0xfa, 0xa7, 0xe5, 0x95, 0x48,
	0x8d, 0x3f, 0x60, 0x7f, 0xd6, 0x30, 0x7a, 0x5a, 0xfd, 0xc1, 0x5f, 0x23, 0x10, 0x45, 0xcf, 0x87,
	0x35, 0x5d, 0x8e, 0x0d, 0xa2, 0xeb, 0x84, 0x36, 0xaa, 0xf7, 0x09, 0xf4, 0xb5, 0x91, 0x22, 0xf3,
	0x5d, 0xc2, 0x59, 0x41, 0x34, 0xa9, 0xa5, 0x36, 0x3e, 0x30, 0x4a, 0x8a, 0x77, 0x00, 0x2e, 0x09,
	0xaf, 0x71, 0x21, 0x1b, 0x34, 0xb2, 0x00, 0x86, 0xff, 0xec, 0xc2, 0xfa, 0xa8, 0x18, 0x97, 0xab,
	0x04, 0xf4, 0x99, 0x80, 0x7d, 0x58, 0x9f, 0xca, 0x22, 0x2e, 0xab, 0x51, 0x4c, 0x24, 0xb8, 0xc1,
	0x5c, 0xc7, 0x8d, 0x8c, 0x45, 0x9e, 0x66, 0x33, 0x22, 0xc2, 0x0d, 0xac, 0x86, 0xcb, 0xc8, 0xcb,
	0x58, 0x66, 0xc4, 0x84, 0x1b, 0xb0, 0x82, 0x33, 0x69, 0x23, 0x95, 0x4a, 0x8b, 0x84, 0xe8, 0xe8,
	0x07, 0x73, 0xdd, 0x3b, 0x02, 0x50, 0x93, 0x99, 0x4e, 0x23, 0x91, 0x8d, 0x62, 0xa2, 0xc5, 0x0d,
	0x5a, 0x08, 0x46, 0x8a, 0xca, 0x4a, 0x8e, 0x62, 0x62, 0xc7, 0x0d, 0xac, 0x86, 0x91, 0x50, 0xd2,
	0x44, 0x4f, 0x3f, 0x60, 0x05, 0x37, 0x4c, 0x21, 0x5f, 0x8b, 0x5c, 0x12, 0x41, 0x6e, 0xb0, 0x00,
	0x70, 0x8f, 0xf9, 0xe4, 0x5b, 0x4b, 0x11, 0x8a, 0x68, 0x1f, 0x89, 0x68, 0x22, 0xcf, 0xd3, 0x6f,
	0x99, 0xa0, 0x7e, 0xb0, 0x00, 0x30, 0xc6, 0x38, 0x13, 0x89, 0xf6, 0x37, 0x8f, 0x7b, 0xb8, 0x1b,
	0x52, 0x28, 0x46, 0x1a, 0x55, 0x65, 0x54, 0xc6, 0xd2, 0xdf, 0xb2, 0x31, 0x1a, 0x60, 0x98, 0x83,
	0xf3, 0x5c, 0xd5, 0xda, 0xfb, 0x09, 0xac, 0x47, 0xaa, 0x0e, 0xd3, 0x62, 0x5c, 0xfa, 0x9d, 0xe3,
	0xde, 0xc9, 0xc6, 0xd3, 0xdb, 0x4f, 0x5a, 0xf9, 0xf9, 0xa4, 0x21, 0x3e, 0x58, 0x8b, 0x54, 0x8d,
	0x8a, 0xf7, 0x39, 0xb8, 0xe8, 0x41, 0x79, 0xea, 0x77, 0xc9, 0x65, 0x6f, 0xc9, 0x65, 0x9e, 0xad,
	0x01, 0x4e, 0x4d, 0xda, 0xf0, 0x6b, 0x70, 0xc8, 0x19, 0xb3, 0xb5, 0x4e, 0x63, 0x9b, 0xc0, 0x24,
	0x23, 0xed, 0x93, 0x52, 0x9b, 0x02, 0xb9, 0xb0, 0x07, 0xd8, 0xe8, 0x94, 0xb1, 0x6a, 0xfa, 0x33,
	0x7b, 0x7c, 0x24, 0x23, 0x86, 0xc1, 0xe9, 0xec, 0x9c, 0x80, 0xe4, 0xe1, 0x5f, 0xba, 0xe0, 0xbe,
	0xd5, 0x22, 0x91, 0x94, 0x24, 0x1e, 0x38, 0x4a, 0x98, 0x49, 0x13, 0x05, 0x65, 0x4a, 0x05, 0x6d,
	0x66, 0xaa, 0x89, 0x61, 0x35, 0x24, 0xcf, 0x94, 0x46, 0x64, 0x14, 0xc2, 0x09, 0x58, 0xc1, 0x19,
	0xc6, 0x95, 0x9c, 0xc7, 0x40, 0xd9, 0xde, 0xb4, 0x98, 0x52, 0xc3, 0xa1, 0x9b, 0x16, 0x7b, 0xc7,
	0xb0, 0x81, 0xbf, 0x67, 0xb2, 0x8a, 0x64, 0xd1, 0x5c, 0x97, 0x36, 0x84, 0x16, 0x69, 0x51, 0xc6,
	0x52, 0xbf, 0xa1, 0x28, 0x6b, 0xe4, 0xdc, 0x86, 0x30, 0xb5, 0x58, 0x7d, 0x8b, 0xb3, 0xaf, 0x93,
	0x41, 0x0b, 0x59, 0x8c, 0xbf, 0xc4, 0x15, 0xb9, 0xed, 0x71, 0x44, 0xbc, 0x1f, 0xc3, 0xcd, 0x85,
	0x75, 0xb3, 0x12, 0x4e, 0x9e, 0xeb, 0x03, 0x43, 0x0d, 0x5b, 0x67, 0xa2, 0x32, 0xa9, 0x49, 0xcb,
	0x82, 0xc8, 0xda, 0x83, 0x41, 0x2c, 0xa7, 0x78, 0xf3, 0x98, 0x2e, 0xab, 0x61, 0xd8, 0xbc, 0xac,
	0x0b, 0xa3, 0xca, 0xb4, 0x30, 0x96, 0xb4, 0x16, 0xd2, 0x22, 0xb4, 0xb7, 0x44, 0xa8, 0x07, 0x4e,
	0xa9, 0x8c, 0xf6, 0x1d, 0x4a, 0x46, 0x92, 0x87, 0xff, 0xe8, 0xc1, 0xf6, 0xe8, 0xf4, 0x39, 0x3a,
	0xcb, 0x8a, 0x2b, 0xd9, 0x01, 0xb8, 0x95, 0x14, 0x31, 0x61, 0x14, 0xd9, 0x09, 0x16, 0x80, 0x77,
	0x02, 0x3b, 0xb9, 0xac, 0x12, 0x19, 0x07, 0x73, 0x9b, 0x2e, 0xd9, 0xac, 0xc2, 0xb8, 0xcc, 0xab,
	0x2a, 0x35, 0x92, 0x8d, 0xf8, 0x10, 0x5b, 0x88, 0xf7, 0x43, 0xd8, 0x65, 0x97, 0xdf, 0x2f, 0xac,
	0xf8, 0x54, 0xaf, 0xe1, 0xcd, 0x9a, 0x9e, 0xcd, 0x8c, 0xd4, 0xf6, 0x98, 0x17, 0xc0, 0x3c, 0x12,
	0x0f, 0x0f, 0x5a, 0x91, 0x78, 0x7c, 0x1f, 0xd6, 0xd1, 0x18, 0x13, 0xde, 0x1e, 0xf3, 0x5c, 0xc7,
	0x99, 0xc9, 0x92, 0x06, 0xf9, 0x88, 0x17, 0x80, 0xf7, 0x18, 0xb6, 0xd3, 0x52, 0xe9, 0x51, 0x71,
	0x56, 0x95, 0x49, 0x25, 0xb5, 0xb6, 0xa7, 0xbc, 0x82, 0x72, 0x5d, 0xa6, 0x29, 0x80, 0xc6, 0xad,
	0x46, 0x2b, 0x93, 0x69, 0x32, 0x31, 0x32, 0x1e, 0x9d, 0x52, 0x7d, 0xc0, 0x95, 0xcd, 0x11, 0xaa,
	0xf1, 0x78, 0xbb, 0x36, 0xf9, 0x3e, 0xd0, 0xcd, 0x1a, 0x52, 0x57, 0x4a, 0x45, 0xf6, 0xba, 0xce,
	0x2f, 0x64, 0x65, 0x2b, 0xc4, 0x12, 0x86, 0x77, 0x23, 0x13, 0x17, 0x32, 0xf3, 0xb7, 0xb9, 0x4c,
	0x92, 0x32, 0xfc, 0x57, 0x07, 0x9c, 0x17, 0xa9, 0xbe, 0xf4, 0x1e, 0x42, 0xe7, 0x2d, 0x1d, 0xdd,
	0x6a, 0x05, 0x98, 0xdf, 0xc4, 0xa0, 0xf3, 0xd6, 0x3b, 0x81, 0x8e, 0xb2, 0x75, 0x62, 0x7f, 0xc9,
	0x6a, 0x29, 0x0d, 0x83, 0x8e, 0xf2, 0x7e, 0x00, 0xdd, 0xd1, 0xa9, 0xdf, 0x23, 0xd3, 0x3b, 0x4b,
	0xa6, 0x18, 0xee, 0xc9, 0xe8, 0xf4, 0xab, 0xc2, 0x54, 0xb3, 0xa0, 0x3b, 0x3a, 0xdd, 0x0f, 0x60,
	0xcd, 0xaa, 0x58, 0x2d, 0x2f, 0xe5, 0xac, 0x69, 0x89, 0x97, 0x72, 0xe6, 0xfd, 0x14, 0xfa, 0x53,
	0x91, 0xd5, 0x7c, 0xd3, 0x37, 0x9e, 0xde, 0x5d, 0x2e, 0x68, 0x4b, 0x69, 0x18, 0xb0, 0xe5, 0x17,
	0xdd, 0x9f, 0x77, 0x86, 0x7f, 0x76, 0xe1, 0xe6, 0xef, 0xd2, 0xca, 0xd4, 0x22, 0x7b, 0x25, 0xf3,
	0xb2, 0x9a, 0x51, 0x9e, 0xce, 0xeb, 0x43, 0xa7, 0x5d, 0x1f, 0x0e, 0xc0, 0x15, 0x53, 0x91, 0x66,
	0xe2, 0x22, 0x93, 0x36, 0x33, 0x17, 0xc0, 0xbc, 0x52, 0xf4, 0x5a, 0x95, 0xe2, 0x3e, 0x6c, 0xe2,
	0x6f, 0xa8, 0xec, 0x05, 0x75, 0xae, 0x97, 0x8a, 0xa6, 0xe8, 0xf4, 0x5b, 0x45, 0x67, 0x0f, 0x06,
	0x22, 0x32, 0xe9, 0x54, 0xda, 0x84, 0xb3, 0x1a, 0x26, 0x5b, 0x5a, 0xd8, 0x11, 0x9b, 0x6c, 0x8d,
	0x8e, 0x4b, 0xbe, 0x4a, 0xab, 0x79, 0x2d, 0x61, 0x05, 0x5b, 0x75, 0x26, 0xea, 0x22, 0xae, 0x66,
	0x36, 0xbb, 0x1a, 0x15, 0x47, 0x2e, 0xea, 0xf1, 0x58, 0x56, 0xda, 0xe6, 0x55, 0xa3, 0x52, 0x57,
	0xc3, 0x36, 0x13, 0xdb, 0xa4, 0xb2, 0x9a, 0x77, 0x68, 0xaf, 0x42, 0x78, 0x21, 0xa2, 0x4b, 0x4a,
	0xab, 0x26, 0x9f, 0x9f, 0x89, 0xe8, 0x12, 0x17, 0x10, 0xa7, 0x95, 0x99, 0x51, 0x52, 0x39, 0x01,
	0x2b, 0xde, 0x43, 0xd8, 0x5e, 0x38, 0x85, 0x26, 0x57, 0x94, 0x56, 0x4e, 0xb0, 0x39, 0x77, 0x7c,
	0x93, 0x2b, 0x7a, 0xbb, 0x4c, 0x04, 0xae, 0x7e, 0x87, 0x43, 0xb2, 0x86, 0xe4, 0xe8, 0x4c, 0x5c,
	0xf8, 0xbb, 0x4c, 0x0e, 0xca, 0x94, 0xc3, 0x95, 0x8c, 0x32, 0x91, 0xe6, 0x74, 0x10, 0x37, 0x79,
	0xbe, 0x36, 0x86, 0x77, 0x43, 0xd7, 0x85, 0x45, 0x7c, 0x8f, 0xef, 0xc6, 0x02, 0xf1, 0xee, 0xc1,
	0x86, 0x12, 0x89, 0x0c, 0x0d, 0x5a, 0x6b, 0xff, 0x16, 0x1b, 0x20, 0xf4, 0x86, 0x10, 0x34, 0xd0,
	0x57, 0x42, 0x85, 0x96, 0x88, 0x4f, 0xec, 0x0c, 0x57, 0x42, 0x3d, 0x67, 0x32, 0xee, 0xc3, 0x66,
	0x54, 0xe6, 0x79, 0x6a, 0xc2, 0x2c, 0xcd, 0x53, 0xe3, 0xdf, 0xe6, 0x12, 0xcf, 0xd8, 0x6f, 0x10,
	0x5a, 0x98, 0x18, 0x19, 0x87, 0x42, 0xfb, 0x7b, 0x6d, 0x13, 0x23, 0xe3, 0x2f, 0x35, 0x52, 0x3a,
	0x49, 0x93, 0x49, 0xc8, 0xc9, 0xf6, 0x29, 0x53, 0x8a, 0x08, 0x37, 0x89, 0xbb, 0x40, 0x4a, 0x48,
	0x09, 0xe2, 0xf3, 0x81, 0x23, 0x40, 0x1d, 0xe0, 0x2e, 0xb8, 0x59, 0x79, 0x65, 0x5d, 0xef, 0xf0,
	0x60, 0x56, 0x5e, 0xb1, 0xe7, 0x1d, 0x40, 0x99, 0x1d, 0xf7, 0xed, 0xc1, 0x97, 0x57, 0xe4, 0x77,
	0x08, 0xb4, 0x0f, 0xeb, 0x78, 0x97, 0x63, 0x22, 0x32, 0x8f, 0x49, 0xc3, 0xe4, 0x7a, 0xc0, 0xd3,
	0x22, 0xf0, 0xd2, 0x26, 0x66, 0x2e, 0x94, 0x92, 0xb1, 0x7f, 0xc8, 0xe7, 0xc4, 0x9a, 0xf7, 0x00,
	0xb6, 0xa6, 0xb9, 0xc8, 0xb2, 0x32, 0xb2, 0xd3, 0x1e, 0xf1, 0xa1, 0x58, 0x90, 0x67, 0xbe, 0x0f,
	0x8d, 0x1e, 0xd2, 0x45, 0xb9, 0xc7, 0x7c, 0x58, 0x8c, 0xba, 0x5e, 0x6b, 0x9e, 0x68, 0x52, 0x17,
	0x97, 0xfe, 0xf1, 0xd2, 0x3c, 0xcf, 0x11, 0xf3, 0x4e, 0x60, 0x77, 0x52, 0x27, 0x32, 0xc4, 0xe3,
	0xd2, 0x36, 0xde, 0x7d, 0x2e, 0x9d, 0x88, 0x9f, 0x21, 0xcc, 0x11, 0x1f, 0xc3, 0x4e, 0xcb, 0x92,
	0x76, 0x34, 0x24, 0xc3, 0xad, 0xb9, 0x21, 0x6d, 0x6b, 0xd9, 0xae, 0xd2, 0xd3, 0xd8, 0x7f, 0xb0,
	0x62, 0x17, 0xe8, 0x69, 0xbc, 0x62, 0xa7, 0xeb, 0x4a, 0xf9, 0x0f, 0x57, 0xec, 0xce, 0xeb, 0x4a,
	0x61, 0xd2, 0xcf, 0xed, 0x42, 0x8d, 0xcf, 0xb7, 0x47, 0xbc, 0x8f, 0xc6, 0x8c, 0x5e, 0x70, 0x8f,
	0x61, 0x47, 0x14, 0x65, 0x11, 0x2e, 0xa6, 0xf4, 0x1f, 0xf3, 0x6c, 0x08, 0xff, 0xba, 0x99, 0x71,
	0xf8, 0xc7, 0x2e, 0x6c, 0x9f, 0x5f, 0x09, 0xf5, 0x7f, 0xeb, 0x53, 0x53, 0x81, 0xba, 0xad, 0x0a,
	0xd4, 0x94, 0x97, 0x5e, 0xab, 0xbc, 0x7c, 0x8f, 0xaa, 0xb4, 0x0b, 0x3d, 0x9d, 0x16, 0xb6, 0x28,
	0xa1, 0x48, 0x57, 0xb1, 0xac, 0x8d, 0xad, 0x48, 0x24, 0x7b, 0xb7, 0xa0, 0xaf, 0x92, 0x30, 0x2d,
	0x6c, 0x31, 0x72, 0x54, 0x32, 0x2a, 0xbc, 0xdb, 0x30, 0x50, 0x49, 0x88, 0xa6, 0xb6, 0x12, 0xa9,
	0xe4, 0xb4, 0x36, 0x98, 0x91, 0x2a, 0x09, 0xc7, 0xa2, 0xce, 0x4c, 0x53, 0x8a, 0x54, 0xf2, 0x12,
	0x55, 0xef, 0x18, 0x36, 0x55, 0x12, 0xe6, 0xe2, 0x1b, 0x3b, 0x0c, 0xf6, 0x3a, 0x26, 0xaf, 0xc4,
	0x37, 0x64, 0x31, 0xfc, 0x1a, 0x00, 0x19, 0x78, 0xc1, 0x8f, 0x94, 0xa6, 0xb3, 0x75, 0x5a, 0x9d,
	0xed, 0x10, 0x80, 0xf6, 0x74, 0x41, 0x7d, 0xda, 0x16, 0x67, 0x44, 0xb8, 0x4d, 0x1f, 0x02, 0xe0,
	0xd6, 0xed, 0x30, 0x93, 0xe1, 0x22, 0x42, 0xc3, 0xc3, 0xbf, 0x77, 0x60, 0xc0, 0xf4, 0x7a, 0x5f,
	0xc1, 0xf6, 0x94, 0xfb, 0x41, 0x98, 0x13, 0x62, 0x9b, 0xdd, 0xd1, 0x52, 0x43, 0xb9, 0xd6, 0x32,
	0x82, 0xad, 0x69, 0x1b, 0xf2, 0x7e, 0x61, 0x0b, 0x88, 0x9d, 0xe3, 0x43, 0x4d, 0x69, 0xf9, 0x4c,
	0xb9, 0xba, 0x58, 0xef, 0x2f, 0x60, 0x93, 0xbc, 0xf9, 0x55, 0xa6, 0x6d, 0x7b, 0xfc, 0xf4, 0x9a,
	0x3b, 0x13, 0x12, 0x50, 0x28, 0x96, 0xf5, 0xf0, 0xaf, 0x5d, 0x70, 0xcf, 0x8d, 0x28, 0xe2, 0x17,
	0xc2, 0x08, 0xfa, 0x22, 0x93, 0x55, 0x64, 0x2c, 0x59, 0xac, 0xcc, 0x5f, 0xe4, 0xdd, 0x8f, 0xbc,
	0xc8, 0x7b, 0x1f, 0x79, 0x91, 0x3b, 0x1f, 0x78, 0x91, 0xf7, 0x17, 0x2f, 0x72, 0xef, 0x11, 0x38,
	0xf4, 0x51, 0x31, 0xa0, 0xed, 0xde, 0xbc, 0xf6, 0x51, 0x11, 0xd0, 0xb0, 0xf7, 0x80, 0xbf, 0xe7,
	0xd6, 0x3e, 0x60, 0x85, 0xdf, 0x27, 0xfc, 0x89, 0xf7, 0x08, 0x9c, 0x38, 0xd5, 0x97, 0x94, 0x45,
	0xab, 0x56, 0xf8, 0x34, 0x08, 0x68, 0xd8, 0xfb, 0x11, 0x0c, 0x2c, 0xc7, 0x2e, 0x19, 0xde, 0x5a,
	0x32, 0x64, 0x3e, 0x03, 0x6b, 0x82, 0x69, 0x5d, 0x48, 0x4c, 0x30, 0x7c, 0xa5, 0xa2, 0x38, 0xfc,
	0x25, 0xec, 0x04, 0x52, 0xab, 0xb2, 0xd0, 0xf2, 0x95, 0xd4, 0xf8, 0x84, 0xc1, 0x8d, 0xd1, 0xe7,
	0x93, 0x4d, 0x2f, 0x94, 0xb1, 0x5b, 0xe6, 0x3c, 0x6c, 0x39, 0x6b, 0xd4, 0xa7, 0xbf, 0x85, 0xad,
	0xb3, 0x5a, 0x4f, 0xbe, 0x4c, 0x44, 0x61, 0x88, 0xf1, 0x5f, 0xc1, 0xfa, 0xb9, 0xb4, 0xec, 0x2f,
	0xbf, 0x90, 0xe6, 0xa7, 0xb2, 0x7f, 0xb0, 0x84, 0xaf, 0x2c, 0xe0, 0x99, 0xff, 0xb7, 0x77, 0x47,
	0x9d, 0xef, 0xde, 0x1d, 0x75, 0xfe, 0xf3, 0xee, 0xa8, 0xf3, 0xa7, 0xf7, 0x47, 0x37, 0xbe, 0x7b,
	0x7f, 0x74, 0xe3, 0xdf, 0xef, 0x8f, 0x6e, 0x5c, 0x0c, 0xe8, 0xef, 0x81, 0xcf, 0xff, 0x17, 0x00,
	0x00, 0xff, 0xff, 0x23, 0xb2, 0x13, 0xf1, 0x5c, 0x10, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PushAgantDataClient is the client API for PushAgantData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PushAgantDataClient interface {
	SendData(ctx context.Context, in *StandData, opts ...grpc.CallOption) (*ResponseMessage, error)
}

type pushAgantDataClient struct {
	cc *grpc.ClientConn
}

func NewPushAgantDataClient(cc *grpc.ClientConn) PushAgantDataClient {
	return &pushAgantDataClient{cc}
}

func (c *pushAgantDataClient) SendData(ctx context.Context, in *StandData, opts ...grpc.CallOption) (*ResponseMessage, error) {
	out := new(ResponseMessage)
	err := c.cc.Invoke(ctx, "/grpc_server.PushAgantData/SendData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PushAgantDataServer is the server API for PushAgantData service.
type PushAgantDataServer interface {
	SendData(context.Context, *StandData) (*ResponseMessage, error)
}

// UnimplementedPushAgantDataServer can be embedded to have forward compatible implementations.
type UnimplementedPushAgantDataServer struct {
}

func (*UnimplementedPushAgantDataServer) SendData(ctx context.Context, req *StandData) (*ResponseMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendData not implemented")
}

func RegisterPushAgantDataServer(s *grpc.Server, srv PushAgantDataServer) {
	s.RegisterService(&_PushAgantData_serviceDesc, srv)
}

func _PushAgantData_SendData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StandData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushAgantDataServer).SendData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_server.PushAgantData/SendData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushAgantDataServer).SendData(ctx, req.(*StandData))
	}
	return interceptor(ctx, in, info, handler)
}

var _PushAgantData_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_server.PushAgantData",
	HandlerType: (*PushAgantDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendData",
			Handler:    _PushAgantData_SendData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "server.proto",
}

func (m *TimesStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimesStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimesStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GuestNice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GuestNice))))
		i--
		dAtA[i] = 0x59
	}
	if m.Guest != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Guest))))
		i--
		dAtA[i] = 0x51
	}
	if m.Steal != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Steal))))
		i--
		dAtA[i] = 0x49
	}
	if m.Softirq != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Softirq))))
		i--
		dAtA[i] = 0x41
	}
	if m.Irq != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Irq))))
		i--
		dAtA[i] = 0x39
	}
	if m.Iowait != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Iowait))))
		i--
		dAtA[i] = 0x31
	}
	if m.Nice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Nice))))
		i--
		dAtA[i] = 0x29
	}
	if m.Idle != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Idle))))
		i--
		dAtA[i] = 0x21
	}
	if m.System != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.System))))
		i--
		dAtA[i] = 0x19
	}
	if m.User != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.User))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Cpu) > 0 {
		i -= len(m.Cpu)
		copy(dAtA[i:], m.Cpu)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Cpu)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InfoStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfoStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Microcode) > 0 {
		i -= len(m.Microcode)
		copy(dAtA[i:], m.Microcode)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Microcode)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Flags) > 0 {
		for iNdEx := len(m.Flags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Flags[iNdEx])
			copy(dAtA[i:], m.Flags[iNdEx])
			i = encodeVarintServer(dAtA, i, uint64(len(m.Flags[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.CacheSize != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.CacheSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Mhz != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mhz))))
		i--
		dAtA[i] = 0x51
	}
	if len(m.ModelName) > 0 {
		i -= len(m.ModelName)
		copy(dAtA[i:], m.ModelName)
		i = encodeVarintServer(dAtA, i, uint64(len(m.ModelName)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Cores != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Cores))
		i--
		dAtA[i] = 0x40
	}
	if len(m.CoreId) > 0 {
		i -= len(m.CoreId)
		copy(dAtA[i:], m.CoreId)
		i = encodeVarintServer(dAtA, i, uint64(len(m.CoreId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PhysicalId) > 0 {
		i -= len(m.PhysicalId)
		copy(dAtA[i:], m.PhysicalId)
		i = encodeVarintServer(dAtA, i, uint64(len(m.PhysicalId)))
		i--
		dAtA[i] = 0x32
	}
	if m.Stepping != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Stepping))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Family) > 0 {
		i -= len(m.Family)
		copy(dAtA[i:], m.Family)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Family)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VendorId) > 0 {
		i -= len(m.VendorId)
		copy(dAtA[i:], m.VendorId)
		i = encodeVarintServer(dAtA, i, uint64(len(m.VendorId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cpu != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Cpu))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cpus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cpus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cpus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CpuTimes) > 0 {
		for iNdEx := len(m.CpuTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CpuTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CpuInfo) > 0 {
		for iNdEx := len(m.CpuInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CpuInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Ipv4) > 0 {
		i -= len(m.Ipv4)
		copy(dAtA[i:], m.Ipv4)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ipv4)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UsageStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InodesUsedPercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.InodesUsedPercent))))
		i--
		dAtA[i] = 0x51
	}
	if m.InodesFree != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.InodesFree))
		i--
		dAtA[i] = 0x48
	}
	if m.InodesUsed != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.InodesUsed))
		i--
		dAtA[i] = 0x40
	}
	if m.InodesTotal != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.InodesTotal))
		i--
		dAtA[i] = 0x38
	}
	if m.UsedPercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UsedPercent))))
		i--
		dAtA[i] = 0x31
	}
	if m.Used != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x28
	}
	if m.Free != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Free))
		i--
		dAtA[i] = 0x20
	}
	if m.Total != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Fstype) > 0 {
		i -= len(m.Fstype)
		copy(dAtA[i:], m.Fstype)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Fstype)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Opts) > 0 {
		for iNdEx := len(m.Opts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Opts[iNdEx])
			copy(dAtA[i:], m.Opts[iNdEx])
			i = encodeVarintServer(dAtA, i, uint64(len(m.Opts[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Fstype) > 0 {
		i -= len(m.Fstype)
		copy(dAtA[i:], m.Fstype)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Fstype)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Mountpoint) > 0 {
		i -= len(m.Mountpoint)
		copy(dAtA[i:], m.Mountpoint)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Mountpoint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IOCountersStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IOCountersStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IOCountersStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.SerialNumber) > 0 {
		i -= len(m.SerialNumber)
		copy(dAtA[i:], m.SerialNumber)
		i = encodeVarintServer(dAtA, i, uint64(len(m.SerialNumber)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x62
	}
	if m.WeightedIO != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.WeightedIO))
		i--
		dAtA[i] = 0x58
	}
	if m.IoTime != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.IoTime))
		i--
		dAtA[i] = 0x50
	}
	if m.IopsInProgress != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.IopsInProgress))
		i--
		dAtA[i] = 0x48
	}
	if m.WriteTime != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.WriteTime))
		i--
		dAtA[i] = 0x40
	}
	if m.ReadTime != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.ReadTime))
		i--
		dAtA[i] = 0x38
	}
	if m.WriteBytes != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.WriteBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.ReadBytes != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.ReadBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.MergedWriteCount != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.MergedWriteCount))
		i--
		dAtA[i] = 0x20
	}
	if m.WriteCount != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.WriteCount))
		i--
		dAtA[i] = 0x18
	}
	if m.MergedReadCount != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.MergedReadCount))
		i--
		dAtA[i] = 0x10
	}
	if m.ReadCount != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.ReadCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Disk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Disk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Disk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IO) > 0 {
		for k := range m.IO {
			v := m.IO[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintServer(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintServer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.P) > 0 {
		for iNdEx := len(m.P) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.P[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.U != nil {
		{
			size, err := m.U.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VirtualMemoryStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualMemoryStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualMemoryStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AnonHugePages != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.AnonHugePages))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.HugePageSize != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.HugePageSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.HugePagesSurp != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.HugePagesSurp))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.HugePagesRsvd != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.HugePagesRsvd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.HugePagesFree != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.HugePagesFree))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.HugePagesTotal != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.HugePagesTotal))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.VmallocChunk != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.VmallocChunk))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.VmallocUsed != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.VmallocUsed))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.VmallocTotal != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.VmallocTotal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.Mapped != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Mapped))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.SwapFree != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.SwapFree))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.SwapTotal != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.SwapTotal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.LowFree != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.LowFree))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.LowTotal != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.LowTotal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.HighFree != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.HighFree))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.HighTotal != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.HighTotal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.CommittedAs != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.CommittedAs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.CommitLimit != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.CommitLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.SwapCached != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.SwapCached))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.PageTables != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.PageTables))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Sunreclaim != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Sunreclaim))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Sreclaimable != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Sreclaimable))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Slab != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Slab))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Shared != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Shared))
		i--
		dAtA[i] = 0x78
	}
	if m.WriteBackTmp != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.WriteBackTmp))
		i--
		dAtA[i] = 0x70
	}
	if m.Dirty != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Dirty))
		i--
		dAtA[i] = 0x68
	}
	if m.WriteBack != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.WriteBack))
		i--
		dAtA[i] = 0x60
	}
	if m.Cached != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Cached))
		i--
		dAtA[i] = 0x58
	}
	if m.Buffers != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Buffers))
		i--
		dAtA[i] = 0x50
	}
	if m.Laundry != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Laundry))
		i--
		dAtA[i] = 0x48
	}
	if m.Wired != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Wired))
		i--
		dAtA[i] = 0x40
	}
	if m.Inactive != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Inactive))
		i--
		dAtA[i] = 0x38
	}
	if m.Active != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Active))
		i--
		dAtA[i] = 0x30
	}
	if m.Free != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Free))
		i--
		dAtA[i] = 0x28
	}
	if m.UsedPercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UsedPercent))))
		i--
		dAtA[i] = 0x21
	}
	if m.Used != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x18
	}
	if m.Available != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Available))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SwapMemoryStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapMemoryStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapMemoryStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PgMajFault != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.PgMajFault))
		i--
		dAtA[i] = 0x50
	}
	if m.PgFault != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.PgFault))
		i--
		dAtA[i] = 0x48
	}
	if m.PgOut != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.PgOut))
		i--
		dAtA[i] = 0x40
	}
	if m.PgIn != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.PgIn))
		i--
		dAtA[i] = 0x38
	}
	if m.Sout != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Sout))
		i--
		dAtA[i] = 0x30
	}
	if m.Sin != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Sin))
		i--
		dAtA[i] = 0x28
	}
	if m.UsedPercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UsedPercent))))
		i--
		dAtA[i] = 0x21
	}
	if m.Free != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Free))
		i--
		dAtA[i] = 0x18
	}
	if m.Used != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SwapDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FreeBytes != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.FreeBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.UsedBytes != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.UsedBytes))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Memory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Memory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Memory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SwapDevices) > 0 {
		for iNdEx := len(m.SwapDevices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SwapDevices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SwapMemory != nil {
		{
			size, err := m.SwapMemory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.VirtualMemory != nil {
		{
			size, err := m.VirtualMemory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StandData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StandData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StandData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Net) > 0 {
		for iNdEx := len(m.Net) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Net[iNdEx])
			copy(dAtA[i:], m.Net[iNdEx])
			i = encodeVarintServer(dAtA, i, uint64(len(m.Net[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Memory != nil {
		{
			size, err := m.Memory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Disk != nil {
		{
			size, err := m.Disk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Cpu != nil {
		{
			size, err := m.Cpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Time != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Ipv4) > 0 {
		i -= len(m.Ipv4)
		copy(dAtA[i:], m.Ipv4)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ipv4)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Serct) > 0 {
		i -= len(m.Serct)
		copy(dAtA[i:], m.Serct)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Serct)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintServer(dAtA []byte, offset int, v uint64) int {
	offset -= sovServer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TimesStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cpu)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.User != 0 {
		n += 9
	}
	if m.System != 0 {
		n += 9
	}
	if m.Idle != 0 {
		n += 9
	}
	if m.Nice != 0 {
		n += 9
	}
	if m.Iowait != 0 {
		n += 9
	}
	if m.Irq != 0 {
		n += 9
	}
	if m.Softirq != 0 {
		n += 9
	}
	if m.Steal != 0 {
		n += 9
	}
	if m.Guest != 0 {
		n += 9
	}
	if m.GuestNice != 0 {
		n += 9
	}
	return n
}

func (m *InfoStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cpu != 0 {
		n += 1 + sovServer(uint64(m.Cpu))
	}
	l = len(m.VendorId)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Family)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Stepping != 0 {
		n += 1 + sovServer(uint64(m.Stepping))
	}
	l = len(m.PhysicalId)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.CoreId)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Cores != 0 {
		n += 1 + sovServer(uint64(m.Cores))
	}
	l = len(m.ModelName)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mhz != 0 {
		n += 9
	}
	if m.CacheSize != 0 {
		n += 1 + sovServer(uint64(m.CacheSize))
	}
	if len(m.Flags) > 0 {
		for _, s := range m.Flags {
			l = len(s)
			n += 1 + l + sovServer(uint64(l))
		}
	}
	l = len(m.Microcode)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	return n
}

func (m *Cpus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CpuInfo) > 0 {
		for _, e := range m.CpuInfo {
			l = e.Size()
			n += 1 + l + sovServer(uint64(l))
		}
	}
	if len(m.CpuTimes) > 0 {
		for _, e := range m.CpuTimes {
			l = e.Size()
			n += 1 + l + sovServer(uint64(l))
		}
	}
	return n
}

func (m *Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Ipv4)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovServer(uint64(m.Time))
	}
	return n
}

func (m *UsageStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Fstype)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovServer(uint64(m.Total))
	}
	if m.Free != 0 {
		n += 1 + sovServer(uint64(m.Free))
	}
	if m.Used != 0 {
		n += 1 + sovServer(uint64(m.Used))
	}
	if m.UsedPercent != 0 {
		n += 9
	}
	if m.InodesTotal != 0 {
		n += 1 + sovServer(uint64(m.InodesTotal))
	}
	if m.InodesUsed != 0 {
		n += 1 + sovServer(uint64(m.InodesUsed))
	}
	if m.InodesFree != 0 {
		n += 1 + sovServer(uint64(m.InodesFree))
	}
	if m.InodesUsedPercent != 0 {
		n += 9
	}
	return n
}

func (m *PartitionStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Mountpoint)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Fstype)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Opts) > 0 {
		for _, s := range m.Opts {
			l = len(s)
			n += 1 + l + sovServer(uint64(l))
		}
	}
	return n
}

func (m *IOCountersStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadCount != 0 {
		n += 1 + sovServer(uint64(m.ReadCount))
	}
	if m.MergedReadCount != 0 {
		n += 1 + sovServer(uint64(m.MergedReadCount))
	}
	if m.WriteCount != 0 {
		n += 1 + sovServer(uint64(m.WriteCount))
	}
	if m.MergedWriteCount != 0 {
		n += 1 + sovServer(uint64(m.MergedWriteCount))
	}
	if m.ReadBytes != 0 {
		n += 1 + sovServer(uint64(m.ReadBytes))
	}
	if m.WriteBytes != 0 {
		n += 1 + sovServer(uint64(m.WriteBytes))
	}
	if m.ReadTime != 0 {
		n += 1 + sovServer(uint64(m.ReadTime))
	}
	if m.WriteTime != 0 {
		n += 1 + sovServer(uint64(m.WriteTime))
	}
	if m.IopsInProgress != 0 {
		n += 1 + sovServer(uint64(m.IopsInProgress))
	}
	if m.IoTime != 0 {
		n += 1 + sovServer(uint64(m.IoTime))
	}
	if m.WeightedIO != 0 {
		n += 1 + sovServer(uint64(m.WeightedIO))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	return n
}

func (m *Disk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.U != nil {
		l = m.U.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.P) > 0 {
		for _, e := range m.P {
			l = e.Size()
			n += 1 + l + sovServer(uint64(l))
		}
	}
	if len(m.IO) > 0 {
		for k, v := range m.IO {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovServer(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovServer(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VirtualMemoryStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovServer(uint64(m.Total))
	}
	if m.Available != 0 {
		n += 1 + sovServer(uint64(m.Available))
	}
	if m.Used != 0 {
		n += 1 + sovServer(uint64(m.Used))
	}
	if m.UsedPercent != 0 {
		n += 9
	}
	if m.Free != 0 {
		n += 1 + sovServer(uint64(m.Free))
	}
	if m.Active != 0 {
		n += 1 + sovServer(uint64(m.Active))
	}
	if m.Inactive != 0 {
		n += 1 + sovServer(uint64(m.Inactive))
	}
	if m.Wired != 0 {
		n += 1 + sovServer(uint64(m.Wired))
	}
	if m.Laundry != 0 {
		n += 1 + sovServer(uint64(m.Laundry))
	}
	if m.Buffers != 0 {
		n += 1 + sovServer(uint64(m.Buffers))
	}
	if m.Cached != 0 {
		n += 1 + sovServer(uint64(m.Cached))
	}
	if m.WriteBack != 0 {
		n += 1 + sovServer(uint64(m.WriteBack))
	}
	if m.Dirty != 0 {
		n += 1 + sovServer(uint64(m.Dirty))
	}
	if m.WriteBackTmp != 0 {
		n += 1 + sovServer(uint64(m.WriteBackTmp))
	}
	if m.Shared != 0 {
		n += 1 + sovServer(uint64(m.Shared))
	}
	if m.Slab != 0 {
		n += 2 + sovServer(uint64(m.Slab))
	}
	if m.Sreclaimable != 0 {
		n += 2 + sovServer(uint64(m.Sreclaimable))
	}
	if m.Sunreclaim != 0 {
		n += 2 + sovServer(uint64(m.Sunreclaim))
	}
	if m.PageTables != 0 {
		n += 2 + sovServer(uint64(m.PageTables))
	}
	if m.SwapCached != 0 {
		n += 2 + sovServer(uint64(m.SwapCached))
	}
	if m.CommitLimit != 0 {
		n += 2 + sovServer(uint64(m.CommitLimit))
	}
	if m.CommittedAs != 0 {
		n += 2 + sovServer(uint64(m.CommittedAs))
	}
	if m.HighTotal != 0 {
		n += 2 + sovServer(uint64(m.HighTotal))
	}
	if m.HighFree != 0 {
		n += 2 + sovServer(uint64(m.HighFree))
	}
	if m.LowTotal != 0 {
		n += 2 + sovServer(uint64(m.LowTotal))
	}
	if m.LowFree != 0 {
		n += 2 + sovServer(uint64(m.LowFree))
	}
	if m.SwapTotal != 0 {
		n += 2 + sovServer(uint64(m.SwapTotal))
	}
	if m.SwapFree != 0 {
		n += 2 + sovServer(uint64(m.SwapFree))
	}
	if m.Mapped != 0 {
		n += 2 + sovServer(uint64(m.Mapped))
	}
	if m.VmallocTotal != 0 {
		n += 2 + sovServer(uint64(m.VmallocTotal))
	}
	if m.VmallocUsed != 0 {
		n += 2 + sovServer(uint64(m.VmallocUsed))
	}
	if m.VmallocChunk != 0 {
		n += 2 + sovServer(uint64(m.VmallocChunk))
	}
	if m.HugePagesTotal != 0 {
		n += 2 + sovServer(uint64(m.HugePagesTotal))
	}
	if m.HugePagesFree != 0 {
		n += 2 + sovServer(uint64(m.HugePagesFree))
	}
	if m.HugePagesRsvd != 0 {
		n += 2 + sovServer(uint64(m.HugePagesRsvd))
	}
	if m.HugePagesSurp != 0 {
		n += 2 + sovServer(uint64(m.HugePagesSurp))
	}
	if m.HugePageSize != 0 {
		n += 2 + sovServer(uint64(m.HugePageSize))
	}
	if m.AnonHugePages != 0 {
		n += 2 + sovServer(uint64(m.AnonHugePages))
	}
	return n
}

func (m *SwapMemoryStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovServer(uint64(m.Total))
	}
	if m.Used != 0 {
		n += 1 + sovServer(uint64(m.Used))
	}
	if m.Free != 0 {
		n += 1 + sovServer(uint64(m.Free))
	}
	if m.UsedPercent != 0 {
		n += 9
	}
	if m.Sin != 0 {
		n += 1 + sovServer(uint64(m.Sin))
	}
	if m.Sout != 0 {
		n += 1 + sovServer(uint64(m.Sout))
	}
	if m.PgIn != 0 {
		n += 1 + sovServer(uint64(m.PgIn))
	}
	if m.PgOut != 0 {
		n += 1 + sovServer(uint64(m.PgOut))
	}
	if m.PgFault != 0 {
		n += 1 + sovServer(uint64(m.PgFault))
	}
	if m.PgMajFault != 0 {
		n += 1 + sovServer(uint64(m.PgMajFault))
	}
	return n
}

func (m *SwapDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.UsedBytes != 0 {
		n += 1 + sovServer(uint64(m.UsedBytes))
	}
	if m.FreeBytes != 0 {
		n += 1 + sovServer(uint64(m.FreeBytes))
	}
	return n
}

func (m *Memory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VirtualMemory != nil {
		l = m.VirtualMemory.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.SwapMemory != nil {
		l = m.SwapMemory.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.SwapDevices) > 0 {
		for _, e := range m.SwapDevices {
			l = e.Size()
			n += 1 + l + sovServer(uint64(l))
		}
	}
	return n
}

func (m *StandData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Serct)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Ipv4)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovServer(uint64(m.Time))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Disk != nil {
		l = m.Disk.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Net) > 0 {
		for _, s := range m.Net {
			l = len(s)
			n += 1 + l + sovServer(uint64(l))
		}
	}
	return n
}

func (m *ResponseMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	return n
}

func sovServer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozServer(x uint64) (n int) {
	return sovServer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TimesStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimesStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimesStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.User = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.System = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Idle = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Nice = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iowait", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Iowait = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Irq", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Irq = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Softirq", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Softirq = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Steal = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Guest = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuestNice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GuestNice = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			m.Cpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Family = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stepping", wireType)
			}
			m.Stepping = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stepping |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cores", wireType)
			}
			m.Cores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cores |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mhz", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mhz = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			m.CacheSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flags = append(m.Flags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Microcode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Microcode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cpus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cpus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cpus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuInfo = append(m.CpuInfo, &InfoStat{})
			if err := m.CpuInfo[len(m.CpuInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuTimes = append(m.CpuTimes, &TimesStat{})
			if err := m.CpuTimes[len(m.CpuTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fstype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fstype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Free", wireType)
			}
			m.Free = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Free |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UsedPercent = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodesTotal", wireType)
			}
			m.InodesTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodesTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodesUsed", wireType)
			}
			m.InodesUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodesUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodesFree", wireType)
			}
			m.InodesFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodesFree |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodesUsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.InodesUsedPercent = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mountpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mountpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fstype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fstype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Opts = append(m.Opts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IOCountersStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IOCountersStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IOCountersStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadCount", wireType)
			}
			m.ReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergedReadCount", wireType)
			}
			m.MergedReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MergedReadCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteCount", wireType)
			}
			m.WriteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergedWriteCount", wireType)
			}
			m.MergedWriteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MergedWriteCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			m.ReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBytes", wireType)
			}
			m.WriteBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTime", wireType)
			}
			m.ReadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTime", wireType)
			}
			m.WriteTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IopsInProgress", wireType)
			}
			m.IopsInProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IopsInProgress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoTime", wireType)
			}
			m.IoTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightedIO", wireType)
			}
			m.WeightedIO = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeightedIO |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Disk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Disk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Disk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field U", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.U == nil {
				m.U = &UsageStat{}
			}
			if err := m.U.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.P = append(m.P, &PartitionStat{})
			if err := m.P[len(m.P)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IO", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IO == nil {
				m.IO = make(map[string]*IOCountersStat)
			}
			var mapkey string
			var mapvalue *IOCountersStat
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthServer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthServer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &IOCountersStat{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.IO[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualMemoryStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualMemoryStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualMemoryStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UsedPercent = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Free", wireType)
			}
			m.Free = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Free |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			m.Active = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Active |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inactive", wireType)
			}
			m.Inactive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inactive |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wired", wireType)
			}
			m.Wired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wired |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Laundry", wireType)
			}
			m.Laundry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Laundry |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffers", wireType)
			}
			m.Buffers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Buffers |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cached", wireType)
			}
			m.Cached = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cached |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBack", wireType)
			}
			m.WriteBack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteBack |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dirty", wireType)
			}
			m.Dirty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dirty |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBackTmp", wireType)
			}
			m.WriteBackTmp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteBackTmp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shared", wireType)
			}
			m.Shared = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shared |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slab", wireType)
			}
			m.Slab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slab |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sreclaimable", wireType)
			}
			m.Sreclaimable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sreclaimable |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunreclaim", wireType)
			}
			m.Sunreclaim = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunreclaim |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageTables", wireType)
			}
			m.PageTables = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageTables |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapCached", wireType)
			}
			m.SwapCached = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapCached |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitLimit", wireType)
			}
			m.CommitLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedAs", wireType)
			}
			m.CommittedAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedAs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighTotal", wireType)
			}
			m.HighTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighFree", wireType)
			}
			m.HighFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighFree |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowTotal", wireType)
			}
			m.LowTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowFree", wireType)
			}
			m.LowFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowFree |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapTotal", wireType)
			}
			m.SwapTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapFree", wireType)
			}
			m.SwapFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapFree |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapped", wireType)
			}
			m.Mapped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mapped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmallocTotal", wireType)
			}
			m.VmallocTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VmallocTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmallocUsed", wireType)
			}
			m.VmallocUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VmallocUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmallocChunk", wireType)
			}
			m.VmallocChunk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VmallocChunk |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePagesTotal", wireType)
			}
			m.HugePagesTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HugePagesTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePagesFree", wireType)
			}
			m.HugePagesFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HugePagesFree |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePagesRsvd", wireType)
			}
			m.HugePagesRsvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HugePagesRsvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePagesSurp", wireType)
			}
			m.HugePagesSurp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HugePagesSurp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePageSize", wireType)
			}
			m.HugePageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HugePageSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnonHugePages", wireType)
			}
			m.AnonHugePages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnonHugePages |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapMemoryStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapMemoryStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapMemoryStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Free", wireType)
			}
			m.Free = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Free |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UsedPercent = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sin", wireType)
			}
			m.Sin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sout", wireType)
			}
			m.Sout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgIn", wireType)
			}
			m.PgIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgIn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgOut", wireType)
			}
			m.PgOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgOut |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgFault", wireType)
			}
			m.PgFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgFault |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgMajFault", wireType)
			}
			m.PgMajFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgMajFault |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedBytes", wireType)
			}
			m.UsedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeBytes", wireType)
			}
			m.FreeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Memory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Memory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Memory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMemory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualMemory == nil {
				m.VirtualMemory = &VirtualMemoryStat{}
			}
			if err := m.VirtualMemory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwapMemory == nil {
				m.SwapMemory = &SwapMemoryStat{}
			}
			if err := m.SwapMemory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwapDevices = append(m.SwapDevices, &SwapDevice{})
			if err := m.SwapDevices[len(m.SwapDevices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StandData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StandData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StandData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serct = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &Cpus{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disk == nil {
				m.Disk = &Disk{}
			}
			if err := m.Disk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &Memory{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Net", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Net = append(m.Net, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipServer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowServer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthServer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupServer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthServer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthServer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowServer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupServer = fmt.Errorf("proto: unexpected end of group")
)
